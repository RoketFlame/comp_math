# Задача 1. Библиотека OpenMP

## Цель эксперимента

Исследовать максимальную и среднюю ошибку алгоритма 11.6 для разных значений eps и размеров сетки, а также исследовать отношение максимальной ошибки ко времени для разных потоков.

## Условия эксперимента

Все замеры происходили на следующей машине
- Процессор: AMD ryzen 5 5600h (L1 кэш - 384 Кб)
- Оперативная память: 16 GB, 3200 MHz
- ОС: WSL2, Ubuntu 22.04.4 LTS

Каждый тест запускался 20 раз, для итогового значения бралась медиана. Флаги для компилятора можно найти в `CMakeLists.txt`. Использовался компилятор gcc 11.4.0. Время работы алгоритма - это только время работы функии `calculate_net()`. Размер блока в каждом тесте - 20. Это значение было выведено эмпирическим путем, для уменьшения времени работы алгоритма.
Стоит отметить, что размер блока никак не влияет на значения, выдаваемые алоритмом, (а следовательно и на ошибку), значения тестов с разными размерами блоков и сетки можно найти в `results.csv`.

## Эксперимент

Перед работой алгоритма сетка была инициализированна нулями. Для проведения эксперимента была выбрана функция $1000x^3 + 2000y^3$, так как для нее порядок значений ошибки не сильно расходится и удобен для сравнения. Отметим, что функция влияет на размер ошибки, на значения на границе в сетке, а следовательно и на кол-во итераций алгоритма. В качестве области определения был выбран "квадрат" $[0,1]$ как некий стандарт.

Реализация алгоритма представлена в `main.c`. Все результаты экспериментов представлены в `thread_N_results.csv`. 


### Thread 12

| Net size | Epsilon | Max         | Average    | Iterations | Time                |
| -------- | ------- | ----------- | ---------- | ---------- | ------------------- |
| 50       | 0.1     | 24.196943   | 9.406749   | 909.0      | 0.0191675           |
| 50       | 0.01    | 2.418075    | 0.94004    | 1469.0     | 0.021599            |
| 50       | 0.001   | 0.242578    | 0.094303   | 2028.0     | 0.0319275           |
| 100      | 0.1     | 98.645808   | 39.129181  | 2285.0     | 0.07733799999999999 |
| 100      | 0.01    | 9.915829    | 3.937575   | 4566.0     | 0.154451            |
| 100      | 0.001   | 0.991814    | 0.393849   | 6852.0     | 0.2266825           |
| 200      | 0.1     | 346.344289  | 134.69887  | 4262.0     | 0.31823500000000005 |
| 200      | 0.01    | 40.101595   | 16.088222  | 12779.0    | 0.9494644999999999  |
| 200      | 0.001   | 4.011018    | 1.609269   | 22017.0    | 1.6271735           |
| 500      | 0.1     | 943.239559  | 335.139297 | 6810.0     | 1.7576055           |
| 500      | 0.01    | 236.110722  | 94.066595  | 35723.0    | 9.204476            |
| 500      | 0.001   | 25.225427   | 10.182324  | 91802.0    | 23.736516           |
| 1000     | 0.1     | 1495.902035 | 480.003301 | 8527.0     | 6.702432            |
| 1000     | 0.01    | 629.86212   | 235.959289 | 54281.0    | 40.661531499999995  |
| 1000     | 0.001   | 100.409029  | 40.559177  | 228056.0   | 181.446275          |

Из результатов в таблице можно заметить, что при размере сетки $\le 200$ значение эпсилон пропорционально максимальной и средней ошибке, однако при бОльших рамерах сетки уменьшение эпсилон не столь существенно уменьшает ошибку. При уменьшении эпсилон в $100$ раз ошибка уменьшится в $15-37$ раз. 

Также можно провести наблюдение, что отношение максимальной ошибки к средней всегда находится в интервале $[2.5, 3.1]$, что можно связать с тем, что на выбранной области определения функция не асцилирует и ее значения не колеблются.

Теперь посмотрим на время выполнения каждого теста. Отметим, что с ростом размера сетки увеличивается отношение времени выполнение при эпсилон = $0.001$ и эпсилон $= 0.1$. Для размера сетки $<=200$ это отношение $<6$, а при сетке 1000х1000 уже состовляет $27.07$, что больше отношения максимальной ошибки, т.е. увеличив время работы алгоритма в $27$ раз мы уменьшим максимальную ошибку в $15$ раз, а среднюю в $12$ при размере сетки $1000$ (При размере сетки $50$ уменьшение эпсилон в $100$ раз замедляет алгоритм в $1.5$ раза, при этом максимальная и средняя ошибка уменьшается в $100$ раз!)

>Очень интересный результат можно пронаблюдать в этих строчках таблицы

>| Net size | Epsilon | Max        | Average   | Iterations | Time                |
>| -------- | ------- | ---------- | --------- | ---------- | ------------------- |
>| 100      | 0.01    | 9.915829   | 3.937575  | 4566.0     | 0.154451            |
>| 200      | 0.1     | 346.344289 | 134.69887 | 4262.0     | 0.31823500000000005 |

>Количество итераций в второй строке немного меньше, чем в первой, однако время работы алгоритма в первом случае в ~$2$ раза меньше, а также размеры максимальной и средней ошибки существенно различаются. Такая же ситуация сохраняется при другом количестве потоков.

Таким образом можно сделать вывод о том, что уменьшение эпсилон при малых размерах сетки существенно уменьшает максимальную и среднюю ошибки, при этом время работы алгоритма увеличивается не столь сильно. На больших же сетках при уменьшении эпсилон отношение уменьшения ошибки к увеличению времени работы несущественно.


### Сравнение ускорения при разном количестве потоков

Количество потоков влияет только на время работы алгоритма. Ниже представлена таблица со временем работы для 1, 6 и 12 потоков.

| Net size | Epsilon | Thread 1            | Thread 6             | Thread 12           |
| -------- | ------- | ------------------- | -------------------- | ------------------- |
| 50       | 0.1     | 0.0071975           | 0.008404499999999999 | 0.0191675           |
| 50       | 0.01    | 0.011261            | 0.013158             | 0.021599            |
| 50       | 0.001   | 0.0152625           | 0.0180785            | 0.0319275           |
| 100      | 0.1     | 0.057452            | 0.047226000000000004 | 0.07733799999999999 |
| 100      | 0.01    | 0.114242            | 0.1021125            | 0.154451            |
| 100      | 0.001   | 0.1709095           | 0.147221             | 0.2266825           |
| 200      | 0.1     | 0.42137199999999997 | 0.24413400000000002  | 0.31823500000000005 |
| 200      | 0.01    | 1.26329             | 0.771578             | 0.9494644999999999  |
| 200      | 0.001   | 2.1735689999999996  | 1.374526             | 1.6271735           |
| 500      | 0.1     | 4.3445415           | 1.705385             | 1.7576055           |
| 500      | 0.01    | 23.0633995          | 8.8596795            | 9.204476            |
| 500      | 0.001   | 59.3784275          | 23.323481            | 23.736516           |
| 1000     | 0.1     | 27.8870355          | 7.442786999999999    | 6.702432            |
| 1000     | 0.01    | 178.85708           | 47.0080545           | 40.661531499999995  |
| 1000     | 0.001   | 709.59011           | 198.59051599999998   | 181.446275          |

Рассмотрим переход с 1 потока на 6. Максимальное ускорение составило $3.8$ раза, при этом на сетке с размером $50$ быстрее всего справился алгоритм с 1 потоком. Существенное ускорение происходит на сетке размером $\ge 500$ — $\ge 2.6$ раз.

Медленнее всех работает алгоритм с 12 потоками для сетки $\le100$, а также для сеток размера $\le500$ 12 потоков работают медленнее 6, хотя разница не большая — $\le2$. Небольшой прирост в скорости есть при размере сетки $=1000$ — $1.1$ раз. Я предполагаю, что такой результат является следствием того, что на тестовой машине всего 12 потоков и при задействии их всех много ресурсов требуется для переключения контекста и управления ими, также это может быть следствием проведения эксперимента на WSL2.

